package bruh

import (
	"fmt"
	"os"
	"bufio"
	"encoding/json"
	"io/ioutil"
	"github.com/gdamore/tcell/v2"
	"github.com/eiannone/keyboard"
	"github.com/gookit/color"
)

type JsonData struct {
	Words []string `json:"words"`
	Phrases []string `json:"phrases"`
	Passage []string `json:"passage"`
}

func main() {
	// Loading in json data
	data, err := ioutil.ReadFile("./data.json")
	if err != nil {
		fmt.Println("Error Reading in data...", err)
		return
	}

	var TextData JsonData

	err = json.Unmarshal(data, &TextData)
	if err != nil {
		fmt.Println("Error decoding json...", err)
		return
	}
	fmt.Println("Words:", TextData.Words)
	fmt.Println("Passage:", TextData.Passage)
	fmt.Println("Phrases:", TextData.Phrases)

	tcellMethod(TextData.Phrases[0])
}

func colourText() {
	scanner := bufio.NewScanner(os.Stdin)

	fmt.Print("Enter text: ")
	scanner.Scan()

	// Create a new color style with grey foreground
	grey := color.New(color.FgGray)

	// Print greyed-out text
	grey.Println(scanner.Text())
}

type TextBox struct {
	text []rune
	x int
	y int
	maxLen int
	style tcell.Style
	styleCorrect tcell.Style
	styleIncorrect tcell.Style
	screen tcell.Screen
	endingRune rune
	checkAgainst string
	windowSize int
	head int
	questionQueue []rune
	inputQueue []rune
}

func (tb *TextBox) init() {
	tb.endingRune = ' '
	tb.maxLen = len(tb.checkAgainst)
	tb.head = 0
	tb.windowSize = 40
	tb.questionQueue = []rune(tb.checkAgainst[tb.head : tb.head + tb.windowSize])
	tb.printText()
}

func (tb *TextBox) update() {
	if tb.head + tb.windowSize >= len(tb.checkAgainst) {
		tb.inputQueue = []rune(tb.text[tb.head:tb.head + (tb.windowSize)])
	} else {
		if len(tb.text) >= tb.windowSize/2 {
			tb.inputQueue = []rune(tb.text[tb.head:tb.head + (tb.windowSize/2)])
		} else {
			tb.inputQueue = []rune(tb.text)
		}
		tb.questionQueue = []rune(tb.checkAgainst[tb.head : tb.head + tb.windowSize])
	}
	tb.printText()
}

func (tb *TextBox) printText() {
	clearLineHoriz(tb.screen, tb.y)
	var comb []rune

	for idx, char := range tb.questionQueue {
		tb.screen.SetContent(tb.x + idx - tb.windowSize/2, tb.y-1, char, comb, tb.style)
	}

	for idx, char := range tb.inputQueue {
		if char == rune(tb.questionQueue[idx]) {
			tb.screen.SetContent(tb.x + idx - tb.windowSize/2, tb.y, tb.questionQueue[idx], comb, tb.styleCorrect)
		} else {
			tb.screen.SetContent(tb.x + idx - tb.windowSize/2, tb.y, tb.questionQueue[idx], comb, tb.styleIncorrect)
		}
	}
}

func (tb *TextBox) appendText(char rune) {
	if len(tb.text) >= tb.windowSize/2 {
		if tb.head + tb.windowSize < len(tb.checkAgainst) {
			tb.head += 1
		}
	}
	if len(tb.text) == tb.maxLen {
		return
	}

	tb.text = append(tb.text, char)
	tb.update()
}

func (tb *TextBox) popChar() {
	if len(tb.text) == 0 {
		return
	}

	if tb.head != 0 {
		tb.head -= 1
	}

	tb.text = tb.text[:len(tb.text)-1]
	tb.update()
	return
}


func tcellMethod(questionString string) {
	screen, err := tcell.NewScreen()
	if err != nil {
		fmt.Println("Error Creating Screen!", err)
		return
	}

	if err := screen.Init(); err != nil {
		fmt.Println("Error initializing", err)
		return
	}

	defer screen.Fini()

	screen.SetStyle(tcell.StyleDefault.
		Foreground(tcell.ColorBlack).
		Background(tcell.ColorWhite))

	screen.Clear()

	width, height := screen.Size()
	emptyFunc(width, height)

	blackStyled := tcell.StyleDefault.
					Foreground(tcell.ColorBlack).
					Background(tcell.ColorWhite)

	greyStyled := tcell.StyleDefault.
					Foreground(tcell.ColorLightGray).
					Background(tcell.ColorWhite)

	redStyled := tcell.StyleDefault.
					Foreground(tcell.ColorBlack).
					Background(tcell.ColorRed)

	greenStyled := tcell.StyleDefault.
					Foreground(tcell.ColorBlack).
					Background(tcell.ColorGreen)

	addStrHoriz(0, height-1, "quit: esc", blackStyled, screen)

	// questionString := "abcdefghijklmnopqrstuvwxyz"

	// addStrHoriz((width/2)-(len(questionString)/2), 0, questionString, blackStyled, screen)

	tb1 := TextBox{
		x: width/2,
		y: 1,
		style: greyStyled,
		screen: screen,
		styleCorrect: greenStyled,
		styleIncorrect: redStyled,
		checkAgainst: questionString,
	}
	tb1.init()

	// Main Event Loop
	for {
		event := screen.PollEvent()
		switch event := event.(type) {
			case *tcell.EventKey:
				if event.Key() == tcell.KeyEscape {
					return
				} else if event.Key() == tcell.KeyLeft {
					continue

				} else if event.Key() == tcell.KeyRight {
					continue

				} else if event.Key() == tcell.KeyUp {
					continue

				} else if event.Key() == tcell.KeyDown {
					continue

				} else if event.Key() == tcell.KeyBackspace || event.Key() == tcell.KeyBackspace2 {
					tb1.popChar()

				} else {
					tb1.appendText(event.Rune())
				}
		}
		screen.Show()
	}
}

func emptyFunc(x, y int) {
	return
}

func addStrHoriz(x, y int, str string, style tcell.Style, screen tcell.Screen) {
	clearLineHoriz(screen, y)
	var comb []rune
	for ind, char := range str {
		screen.SetContent(x+ind, y, char, comb, style)
	}
}

func addStrVert(x, y int, str string, style tcell.Style, screen tcell.Screen) {
	clearLineVert(screen, x)
	var comb []rune
	for ind, char := range str {
		screen.SetContent(x, y+ind, char, comb, style)
	}
	screen.ShowCursor(0, 0)
	screen.Show()
}

func clearLineHoriz(screen tcell.Screen, y int) {
	width, _ := screen.Size()

	for x := 0; x < width; x++ {
		screen.SetContent(x, y, ' ', nil, tcell.StyleDefault)
	}
}

func clearLineVert(screen tcell.Screen, x int) {
	_, height := screen.Size()

	for y := 0; y < height; y++ {
		screen.SetContent(x, y, ' ', nil, tcell.StyleDefault)
	}
}

func keyboardMethod() {
	err := keyboard.Open()
	if err != nil {
		panic(err)
	}
	defer keyboard.Close()

	var input string
	fmt.Println("Input:", input)

	fmt.Print("Enter text: ")
	for {
		char, key, err := keyboard.GetSingleKey()
		if err != nil {
			panic(err)
		}

		if key == keyboard.KeyEnter {
			break
		}

		if key == keyboard.KeySpace {
			input += " "
		}

		input += string(char)

		fmt.Println(string(char))
		fmt.Print("\033[1A") // move up
		fmt.Print("\033[1A") // move up
		fmt.Print("\033[2K") // Clear current line
		fmt.Print("\033[0G") // Set the cursor to the start of the current line
		fmt.Println("Input:", input)
		fmt.Print("Enter text:", input)
	}

	fmt.Println("Input:", input)
}